import pandas as pd
from datetime import datetime, timedelta
from get_stock_data import StockData
import numpy as np


class EqualWeightPortfolio(object):

    def __init__(self, start, end, stock_file, invested_cap):
        self.data_object = StockData(start=start, end=end, stock_file=stock_file)

        # Pandas Dataframe of historical data:
        self.historical_data = self.data_object.historical_data

        # $'s invested in portfolio
        self.invested_cap = invested_cap

        # List of tickers which received a data response from Yahoo Finance
        self.good_tickers = self.data_object.good_tickers

        # Create initial portfolio
        self.initial_values = pd.DataFrame(columns=['num_shares', 'share_price', 'total_cap'], index=[self.good_tickers])
        self.initial_portfolio()

        # Determine rebalance dates
        self.get_rebalance_dates()

        # Get price returns
        self.get_price_return()

    def rebalance_price_return(self):
        """
        Rebalance portfolio, or create a new one if it has no stocks in it yet
        Dataframe object with:
            Ticker (index)
            Number_shares
            Share_price

        Number_shares = (invested_cap / len(good_tickers)) / Share_price
        """
        pass

    def initial_portfolio(self):
        """From row with first date in historical_data, get 'stock_Close' for each stock in 'good_tickers'"""

        # Set closing price of each stock = closing price of stock on first day
        for stock in self.good_tickers:
            share_price = self.historical_data.iloc[0]['{}_Close'.format(stock)]
            self.initial_values.set_value(stock, 'share_price', share_price)

        # Stocks that have a closing price, excludes stocks that have not traded yet at this time
        stocks_w_prices = self.initial_values[(self.initial_values.share_price > 0)]

        # Set number of shares in portfolio for each stock IF share price > 0
        for index, stock in stocks_w_prices.iterrows():
            num_shares = (self.invested_cap / len(stocks_w_prices.index)) / stock.share_price
            self.initial_values.set_value(index, 'num_shares', num_shares)

        self.initial_values['total_value'] = self.initial_values['num_shares'] * self.initial_values['share_price']

        self.initial_values.to_csv('initvals.csv')



    def get_total_return(self):
        """Total return, when measuring performance, is the actual rate of return of an
        investment or a pool of investments over a given evaluation period. Total return
        includes interest, capital gains, dividends and distributions realized over a
        given period of time."""

        pass

    def get_price_return(self):
        """The price return is the rate of return on an investment portfolio,
        where the return measure takes into account only the capital appreciation of
        the portfolio, while the income generated by the assets in the portfolio,
        in the form of interest and dividends, is ignored."""

        # i = 0
        # for index, period in self.price_return.iterrows():
        #     # new_value = sum of: (for each stock: (# of shares from prior period * last price))
        #     new_value = 0
        #     print(self.price_return.index.values[i])
        #     i = i + 1
        #     self.price_return.set_value(index, 'portfolio_value', new_value)

        self.price_return = pd.DataFrame(columns=['portfolio_value'], index=self.historical_data.index.values)

        t = 0
        while t < len(self.rebalance_dates) - 1:
            period = self.price_return.loc[(self.price_return.index >= self.rebalance_dates[t]) &
                                  (self.price_return.index <= self.rebalance_dates[t + 1])]
            t +=1
            print(period)




    def get_rebalance_dates(self):
        """Rebalance date are the last trading day of each year,
        12-31 or closest prior trading day is 12-31 is a holiday / weekend. Also, the period start date is at
        the beginning because the portfolio is balanced for the first time then"""

        self.rebalance_dates = [start, ]

        for year in range(start.year, end.year + 1):
            date = self.historical_data.loc[self.historical_data.index <= datetime(year, 12, 31)].tail(1).index.values[0]

            # Prevent attempting to rebalance at a date that hasn't happened yet
            # if date > datetime.now():
            #     date = datetime.now()


            # Add dates to list
            self.rebalance_dates.append(date)

if __name__ == '__main__':

    # File with list of stocks
    stock_file = 'djt_components.csv'

    # Set the Start and End date ranges, invested capital
    start = datetime(2007, 1, 1)
    end = datetime(2016, 12, 31)
    invested_cap = 10000

    # Create new portfolio
    p = EqualWeightPortfolio(start=start,
                  end=end,
                  stock_file=stock_file,
                  invested_cap=invested_cap)

